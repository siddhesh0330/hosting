
#6a : grammer using nltk. Analyze a sentence using the same
import nltk
grammar = nltk.CFG.fromstring("""
S -> NP VP
VP -> V NP | V NP PP
PP -> P NP
V -> "saw"|"eat"
NP -> "john"|"shone"| Det N | Det N PP
Det -> "a"|"an"|"the"|"my"
N -> "man"|"dog"|"home"
P -> "in" | "on" | "by" | "with" """)
row = "john saw shone"
words = row.split()
print(words)
modal = nltk.RecursiveDescentParser(grammar)
print(list(modal.parse(words)))
for tree in modal.parse(words):
    print(tree)
    tree.pretty_print()

# 6B:  Accept the input string with Regular expression of FA: 101+ .
import re
def FA(s):
    pattran = '^101'
    if re.match(pattran,s):
        print("accept")
    else:
        print("reject")
def FA2(s):
    if len(s) < 3:
        return "Rejected"
        # first three characteristics are fixed. Therefore checking them using index
    if s[0] == '1':
        if s[1] == '0':
            if s[2] == '1':
    # After index 2 only "1" can appear. Therefore break the process if any other character is detected
                for i in range(3, len(s)):
                    if s[i] != '1':
                        return "Rejected"
                return "Accepted"
            return "Rejected"
        return "Rejected"
    return "Rejected"
inputs = ['1', '10101', '101', '10111', '101101',""]
for i in inputs:
    print(FA2(i))

# 6c :  Accept the input string with Regular expression of FA: (a+b)*bba
def FA(s):
    pattern = r'^(a+b)*bba$'
    if re.match(pattern, s):
        print(f"{s}: accept")
    else:
        print(f"{s}: reject")
def FA2(s):
    size = 0
    # scan complete string and make sure that it contains only 'a' & 'b'
    for i in s:
        if i == 'a' or i == 'b':
            size += 1
        else:
            return "Rejected"
    # After checking that it contains only 'a' & 'b'
    # check it's length it should be 3 atleast
    if size >= 3:
        # check the last 3 elements
        if s[size - 3] == 'b':
            if s[size - 2] == 'b':
                if s[size - 1] == 'a':
                    return "Accepted"
                return "Rejected"
            return "Rejected"
        return "Rejected"
    return "Rejected"


inputs = ['bba', 'ababbba', 'abba','abb', 'baba','bbb','aba']
for i in inputs:
    print(FA2(i))

# 6d : shift reduce, Implementation of Deductive Chart Parsing using context free grammar and a given sentence.

import nltk
grammar = nltk.CFG.fromstring("""
S -> NP VP
VP -> V NP | V NP PP
PP -> P NP
V -> "saw"|"eat"
NP -> "john"|"shone"| Det N | Det N PP
Det -> "a"|"an"|"the"|"my"
N -> "man"|"dog"|"home"
P -> "in" | "on" | "by" | "with" """)
row = "john saw shone"
words = row.split()
print(words)
modal = nltk.RecursiveDescentParser(grammar)
print(list(modal.parse(words)))
for tree in modal.parse(words):
    print(tree)
    tree.pretty_print()
print("Shift reduce")
sr_parse = nltk.ShiftReduceParser(grammar, trace=2)
sent = "saw a dog".split()
for tree1 in sr_parse.parse(sent):
    print(tree1)
    tree1.pretty_print()
