
// SPDX-License-Identifier: GPL-3.0

/* s1 .write a program in solidity. To check if the roll number entered by the
user is in the range of roll numbers in an array and if the number is even
then allow the student else deny.
*/

pragma solidity >=0.8.2 <0.9.0;


contract one {
    uint256[]  validRollNumbers;
    constructor(uint256[] memory _validRollNumbers) {
        validRollNumbers = _validRollNumbers;
    }
    function isRollNumberValidAndEven(uint256 _rollNumber) public view returns (string memory) {
        bool rollNumberExists = false;
        bool isEven = false;

        for (uint256 i = 0; i < validRollNumbers.length; i++) {
            if (validRollNumbers[i] == _rollNumber) {
                rollNumberExists = true;
                break;
            }
        }
        if (_rollNumber % 2 == 0) {
            isEven = true;
        }
        if (rollNumberExists && isEven) {
            return "student allow";
        } else {
            return "student don,t allow";
        }
    }
}
-------------------------------------------------------------------------------------------------------

// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.2 <0.9.0;

/*
s2.To overload the function of bitwise AND operation and logical AND
operation. On the inputs taken from the user.
*/
pragma solidity ^0.8.0;

contract tow {
    function andOperation(uint256 _a, uint256 _b) public pure returns (uint256) {
        return _a & _b;
    }
    function andOperation(bool _a, bool _b) public pure returns (bool) {
        return _a && _b;
    }
}

-------------------------------------------------------------------------------------------------------

// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.2 <0.9.0;

/*
s3.Write a solidity program Take 2 inputs from the user and determine
weather the value of 1st number is greater than the second number if
greater then find AND operation values else find the OR operation.
*/

contract three {
    function tree(uint256 _a, uint256 _b) public pure returns (uint256) {
        if (_a > _b) {
            return _a & _b;
        } else {
            return _a | _b;
        }
    }
}
-------------------------------------------------------------------------------------------------------

// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.2 <0.9.0;

// s4.Write a solidity program To find addition of any 5 numbers of an array of 10 numbers with using the index position.

contract four {
    uint256[]  numbers;

    constructor(uint256[] memory _initialNumbers) {
        require(_initialNumbers.length == 10, "Initial numbers array must have 10 elements");
        numbers = _initialNumbers;
    }
    function addNumbers() public view returns (uint256) {
        uint256 sum = 0;
        for (uint256 i = 0; i < numbers.length; i++) {
            if((i+1)%2 == 0) {sum += numbers[i];}
        }
        return sum;
    }
}


-------------------------------------------------------------------------------------------------------

// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.2 <0.9.0;

/*s5. Write a program in solidity addition of 2 numbers is greater than any
one of the number and then find the product of lesser number and not
the greater number
*/

contract five {
    function Check(int256 num1, int256 num2) public pure returns (int256 product){
        if ((num1 + num2) > num1 || (num1 + num2) > num2) {
            if (num1 < num2) {
                product = num1 * ~num2;
            } else {
                product = num2 * ~num1;
            }
        return product;
        }
    }
}
-------------------------------------------------------------------------------------------------------

/*
s6 : rite a solidity program to find sum of the array of 10 numbers taken
from the user and also find the AND operation of 1,3,5,7,9th no. of an
array and Or operation of even position no. and hence find the product
of the results and create a smart contract to find whether the product is
the part of product of an array or not

*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Q6 {


    uint256[] numbers;
   constructor(uint256[] memory _initialNumbers) {
        require(_initialNumbers.length == 10, "Initial numbers array must have 10 elements");
        numbers = _initialNumbers;
    }
    function isProductInArray() public view returns (bool) {
         uint256 sum = 0;
         uint256 andopp = numbers[0];
         uint256 oropp = numbers[1];
        for (uint256 i = 0; i < 10; i++) {
            sum += numbers[i];
            if((i+1)%2 == 0){ andopp &= numbers[i];}
            if((i+1)%2 != 0){ oropp |= numbers[i];}
        }
        uint256 product = andopp * oropp;
        uint256 arrayProduct = 1;
        for (uint256 i = 0; i < 10; i++) {
            if(numbers[i] == product){
                product = numbers[i];
            }
        }
        return product == arrayProduct;
    }
}

-------------------------------------------------------------------------------------------------------

/*
s7 : Write a solidarity program to find the
modulas of addition of two numbers with DD addmod(DD)
and modulas of multiplication of two numbers with MM mulmod(mm)
which are achived bye performing and operation of your DD and MM , DD & MM
from your date of Birth and OR operation of your YY and YY from , YY | YY
year of birth Where DD , MM, year of birth must be entered by the user.
*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract seven {

    function getDateOfBirth(uint256 _dd, uint256 _mm, uint256 _yy1, uint256 _yy2) public pure returns (uint256 result1 , uint256 result2, uint256 result3, uint256 result4){
        uint256 result1 = _dd & _mm;
        uint256 result2 = _yy1 | _yy2;
        uint256 result3 = addmod(result1 , result2, _dd);
        uint256 result4 = mulmod(result1, result2, _mm);
        return(result1,result2,result3,result4);

    }
}

-------------------------------------------------------------------------------------------------------

/*
s8. Write a solidity program to overload bitwise or operator for 2 3 and 4
parameters and then perform multiplication on the values passed in to 2
parameters, addition of the values passed in 3 parameters and
subtraction of values in 4 parameters.
*/

// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.2 <0.9.0;


contract BitwiseOperatorOverloading {
    function bitwiseOr(uint256 _a, uint256 _b) public pure returns (uint256 mul,uint256 or) {
        //return _a | _b;
        uint256 mul = _a * _b;
        uint256 or = _a | _b;
        return (mul,or);
    }

    function bitwiseOr(uint256 _a, uint256 _b, uint256 _c) public pure returns (uint256 add,uint256 or) {
        //return _a | _b | _c;
        uint256 add = _a + _b + _c;
        uint256 or = _a | _b | _c;
        return (add,or);
    }

    function bitwiseOr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) public pure returns (uint256 sub,uint256 or) {
       // return _a | _b | _c | _d;
        uint256 sub = _a - _b - _c - _d;
        uint256 or = _a | _b | _c | _d;
        return (sub,or);
        }

}
-------------------------------------------------------------------------------------------------------

/*
s9 : Write a solidarity program to find whether a number is even or odd
and another number is prime or composite and hence find the bit vise
AND and bit vise OR of the results of product of the 2 numbers and if
the result is even then allow the student else denied.
*/


// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract NumberChecker {
    // Function to check if a number is even
    function isEven(uint256 number) internal pure returns (bool) {
        return number % 2 == 0;
    }

    // Function to check if a number is prime
    function isPrime(uint256 number) internal pure returns (bool) {
        if (number <= 1) {
            return false;
        }
        for (uint256 i = 2; i * i <= number; i++) {
            if (number % i == 0) {
                return false;
            }
        }
        return true;
    }


    // Function to determine if the student is allowed based on the provided numbers
    function allowStudent(uint256 number1, uint256 number2) public pure returns (bool) {
        bool isNumber1Even = isEven(number1);
        bool isNumber2Prime = isPrime(number2);
        uint256 resultAND = number1 & number2;
        uint256 resultOR = number1 | number2;
        uint256 multipliedResult = resultAND * resultOR;
        bool isResultEven = isEven(multipliedResult);
        if (isResultEven) {
            return true;
        } else {
            return false;
        }
    }
}


---------------------------------------------####################----------------------------------------------------------

/# 1)A simple client class that generates the private and public keys by using the builtin Python RSA algorithm and test it.
#pip install pycryptodomex,pycrypto,pycryptodomex
import Cryptodome
from Cryptodome.PublicKey import RSA
from Cryptodome.Signature import PKCS1_v1_5
import binascii


class Client:
    def __init__(self):
        random = Cryptodome.Random.new().read
        self._private_key = RSA.generate(1024, random)
        self._public_key = self._private_key.publickey()
        self._signer = PKCS1_v1_5.new(self._private_key)

    def identity(self):
        return binascii.hexlify(self._public_key.exportKey(format='DER')).decode('ascii')


user = Client()
print(user.identity())
user2 = Client()
print(user2.identity())


-----------------------------------------


# 1b transaction class to send and receive money and test it.
import Cryptodome
import datetime
import collections
from Cryptodome.Hash import SHA
from Cryptodome.PublicKey import RSA
from Cryptodome.Signature import PKCS1_v1_5
import binascii


class Transaction:
 def __init__(self, sender, recipient, value):
  self.sender = sender
  self.recipient = recipient
  self.value = value
  self.time = datetime.datetime.now()
 def to_dict(self):
  if self.sender == "Genesis":
    identity = "Genesis"
  else:
    identity = self.sender.identity
    return collections.OrderedDict({
    'sender':self.sender,
    'recipient':self.recipient,
    'value':self.value,
    'time':self.time})
 def sign_transaction(self):
  private_key = self.sender._private_key
  signer = PKCS1_v1_5.new(private_key)
  h = SHA.new(str(self.to_dict()).encode('utf8'))
  return binascii.hexlify(signer.sign(h)).decode('ascii')
t = Transaction(user,user2.identity, 5.0)
signature = t.sign_transaction()
print("Signature: ", signature)


-----------------------------------------

# 1c Create multiple transactions and display them.import Cryptodome
import datetime
import collections
from Cryptodome.Hash import SHA
from Cryptodome.PublicKey import RSA
from Cryptodome.Signature import PKCS1_v1_5
import binascii


user3 = Client()
user4 = Client()
def display_transaction(transaction):
 dict = transaction.to_dict()
 print("Sender: " + str(dict['sender']))
 print('------')
 print("Recipient: " + str(dict['recipient']))
 print('------')
 print("Value: " + str(dict['value']))
 print('------')
 print("Time: " + str(dict['time']))
 print('--------------------------------------------------------------------------------------------------------------')
transaction = []
Seema = Client()
Vijay = Client()
t1 = Transaction(Omkar, user.identity(), 15.0)
t1.sign_transaction()
transaction.append(t1)
t2 = Transaction(Omkar, Seema.identity(), 6.0)
t2.sign_transaction()
transaction.append(t2)
t3 = Transaction(Sophia, Vijay.identity(), 2.0)
t3.sign_transaction()
transaction.append(t3)
t4 = Transaction(Seema, user.identity(), 4.0)
t4.sign_transaction()
transaction.append(t4)
for transaction in transaction:
 display_transaction(transaction)




 -------------------------------------------------------------------------------------------------------

 # 1d Create a blockchain, a genesis block and execute it.
import datetime
import hashlib
class Block:
 def __init__(self, previous_block_hash, data, timestamp):
  self.previous_block_hash = previous_block_hash
  self.data = data
  self.timestamp = timestamp
  self.hash = self.get_hash()
 def create_genesis_block():
  return Block("0", "0", datetime.datetime.now())
 def get_hash(self):
  header = (str(self.previous_block_hash)+str(self.data)+str(self.timestamp))
  inner_hash = hashlib.sha256(header.encode()).hexdigest().encode()
  comp_hash = hashlib.sha256(inner_hash).hexdigest()
  return comp_hash
# from dummyblock import Block

number_of_blocks = 21
Blockchain = [Block.create_genesis_block()]
print(' Genesis Block is Created')
print("Hash: %s" % Blockchain[0].hash)
for i in range(1, number_of_blocks):
 Blockchain.append(Block(Blockchain[i - 1].hash, "Block number %d" % i,
datetime.datetime.now()))
print("%d blocks created" % i)
print("Hash: %s" % Blockchain[-i].hash)

-----------------------------------------

# 1e Create a mining function and test it.
from hashlib import sha256
MAX_NONCE = 100000000000
def SHA256(text):
 return sha256(text.encode("ascii")).hexdigest()
def mine(block_number, transactions, previous_hash, prefix_zeros):
  prefix_str = '0'*prefix_zeros
  for nonce in range(MAX_NONCE):
    text = str(block_number)+transactions+previous_hash+str(nonce)
    new_hash = SHA256(text)
    if new_hash.startswith(prefix_str):
      print(f"Yay! Successfully mined bitcoins with nonce value:{nonce}")
      return new_hash
  raise BaseException(f"Couldn't find correct has after trying {MAX_NONCE}times")
if __name__ == '__main__':
 transactions ='''
 Dhaval->Bhavan->20,
 Mando->Cara->45
 '''
difficulty = 2 #trying changing this to highe number and you will see it will take more time for mininig as difficulty increases
import time
start = time.time()
print("Mining has started")
new_hash = mine(5,
transactions,'a34e0074f69db033348600edbe8139c96ecc389af7ff8483bc2d9f180c02754c', difficulty)
total_time = str((time.time() -start))
print(f"Mining Ended.Mining took: {total_time} seconds")
print(new_hash)

-----------------------------------------

# 1f Add blocks to the minor and dump the blockchain.

import datetime
import hashlib

class Block:
 blockNo = 0
 data = None
 next = None
 hash = None
 nonce = 0
 previous_hash = 0x0
 timestamp = datetime.datetime.now()
 def __init__(self, data):
  self.data = data
 def hash(self):
  h = hashlib.sha256()
  h.update(
  str(self.nonce).encode('utf-8') +
  str(self.data).encode('utf-8') +
  str(self.previous_hash).encode('utf-8') +
  str(self.timestamp).encode('utf-8') +
  str(self.blockNo).encode('utf-8')
  )
  return h.hexdigest()
  def __str__(self):
    return "Block Hash: " + str(self.hash()) + "\nBlock No: " + str(self.blockNo) + "\nBlock Data: " + str(self.data) + "\nHashes: " + str(self.nonce) + "\n-----------------------------------------------------------"
class Blockchain:
 diff = 20
 maxNonce = 2 ** 32
 target = 2 ** (256 - diff)
 block = Block("Genesis")
 dummy = head = block
 def add(self, block):
  block.previous_hash = self.block.hash()
  block.blockNo = self.block.blockNo + 1
  self.block.next = block
  self.block = self.block.next
 def mine(self, block):
  for n in range(self.maxNonce):
    if int(block.hash(), 16) <= self.target:
      self.add(block)
      print(block)
      break
    else:
      block.nonce += 1
blockchain = Blockchain()
for n in range(10):
 blockchain.mine(Block("Block " + str(n + 1)))
while blockchain.head is not None:
 print(blockchain.head)
 blockchain.head = blockchain.head.next


-------------------------------------------------------------------------------------------------------

//SPDX-License-Identifier: GPL-3.0
//2B : Increment Decrement Counter

pragma solidity >=0.8.2 <0.9.0;
contract Counter {
 uint256 public num;
 function input(uint256 number) public{
 num = number;
 }
 function increment() public view returns (uint256) {
 return num+1;
 }
 function decrement() public view returns (uint256) {
 return num-1;
 }
}


-------------------------------------------------------------------------------------------------------

//SPDX-License-Identifier: GPL-3.0

// 3 : Operators (Logical, Assignment, Bitwise, Ternary, Comparison)
pragma solidity >=0.8.2 <0.9.0;
contract operators{
 uint256 num1;
 uint256 num2;
 uint256 and;
 uint256 or;
 bool logicaland;
 bool logicalor;
 function store1(uint256 a) public{
 num1=a;
}
function store2(uint256 b) public{
 num2=b;
 and=num1&num2;
 or=num1|num2;
 logicaland=num1 >6 && num2 <3;
 logicalor=num1 >4 || num2 <3;
}
function BitwiseAND()public view returns (uint256){
 return and;
}
function BitwiseOR()public view returns (uint256){
 return or;
}
function LogicalAND()public view returns (bool){
 return logicaland;
}
function LogicalOR()public view returns (bool){
 return logicalor;
}
 function equals(uint256 a, uint256 b) public pure returns (uint256) {
 a=b;
 return a ;
 }
 function isNotEqual(uint256 a, uint256 b) public pure returns (bool) {
 return a != b;
 }
 function isGreater(uint256 a, uint256 b) public pure returns (bool) {
 return a > b;
 }
 function isLesser(uint256 a, uint256 b) public pure returns (bool) {
 return a < b;
 }
 function isLessThanEqual(uint256 a, uint256 b) public pure returns (bool) {
 return a <= b;
 }
 function isGreaterThanEqual(uint256 a, uint256 b) public pure returns (bool) {
 return a >= b;
 }
function ternary(uint256 a, uint256 b) public pure returns (uint256) {
 return a>b ? a: b ;
 }
}


-------------------------------------------------------------------------------------------------------


// SPDX-License-Identifier: GPL-3.0

//4 : Functions Overloading [Bitwise and Arithmetic], Mathematical Functions
pragma solidity >=0.8.2 <0.9.0;
contract ArithmeticFunctionOverloading {
function add(uint256 num1, uint256 num2) public pure returns (uint256) {
return num1 + num2;
}
function add(string memory a, string memory b) public pure returns (string memory) {
return string(abi.encodePacked(a, b));
}
}


-------------------------------------------------------------------------------------------------------


//SPDX-License-Identifier: GPL-3.0

/*
5 : Create a Smart Contract for Patkar-Varde College which comprises of a set of Student
Name, Roll Number, Class (30 entries) and another set of classroom numbers between 45 to
49. Verify if the student is between roll number 1 to 5 then allocate Room No. 45, if roll number
is between 6 to 10 then allocate 46 and so on.
Note: User must enter the roll number and then classroom must be displayed.
*/
pragma solidity >=0.8.2 <0.9.0;
contract PatkarCollege {
 struct Student {
 string name;
 uint256 rollNumber;
 string studentClass;
 uint256 allocatedClassroom;
 }
 Student[30] public studentinfo;
 constructor() {
 studentinfo[0] = Student("Mansi",1 , "MSc IT", 0);
 studentinfo[1] = Student("Sophia", 2, "MSc IT", 0);
 studentinfo[2] = Student("Omkar", 3, "MSc IT", 0);
 studentinfo[3] = Student("Amulya", 4, "MSc CS", 0);
 studentinfo[4] = Student("Sakshi", 5, "MSc IT", 0);
 studentinfo[5] = Student("Pramod", 6, "MSc IT", 0);
 studentinfo[6] = Student("Ravi", 7, "MSc CS", 0);
 studentinfo[7] = Student("Leo", 8, "MSc IT", 0);
 studentinfo[8] = Student("Akhil", 9, "MSc IT", 0);
 studentinfo[9] = Student("Ajith", 10, "MSc IT", 0);
 studentinfo[10] = Student("Nepolean", 11, "MSc CS", 0);
 studentinfo[11] = Student("Leeza", 12, "MSc IT", 0);
 studentinfo[12] = Student("Liya", 13, "MSc IT", 0);
 studentinfo[13] = Student("Sumathi", 14, "MSc IT", 0);
 studentinfo[14] = Student("Ramani", 15, "MSc IT", 0);
 studentinfo[15] = Student("Sreelaxmi", 16, "MSc CS", 0);
 studentinfo[16] = Student("Vinayak", 17, "MSc IT", 0);
 studentinfo[17] = Student("Vishnu", 18, "MSc IT", 0);
 studentinfo[18] = Student("Shiyam", 19, "MSc CS", 0);
 studentinfo[19] = Student("Alan", 20, "MSc CS", 0);
 studentinfo[20] = Student("Shri Hari", 21, "MSc IT", 0);
 studentinfo[21] = Student("Swapnali", 22, "MSc IT", 0);
 studentinfo[22] = Student("Priyanka", 23, "MSc CS", 0);
 studentinfo[23] = Student("Sameer", 24, "MSc IT", 0);
 studentinfo[24] = Student("Pranay", 25, "MSc IT", 0);
 studentinfo[25] = Student("Jessy", 26, "MSc IT", 0);
 studentinfo[26] = Student("Philip", 27, "MSc CS", 0);
 studentinfo[27] = Student("Mathew", 28, "MSc IT", 0);
 studentinfo[28] = Student("Flavia", 29, "MSc IT", 0);
 studentinfo[29] = Student("Shivam", 30, "MSc IT", 0);

for (uint256 i = 0; i < studentinfo.length; i++) {
 studentinfo[i].allocatedClassroom = allocateClassroom(studentinfo[i].rollNumber);
 }
 }
function allocateClassroom(uint256 _rollNumber) internal pure returns (uint256) {
 require(_rollNumber >= 1 && _rollNumber <= 30, "Invalid roll number. Must be between 1 and 30.");
 if (_rollNumber >= 1 && _rollNumber <= 5) {
 return 45;
 } else if (_rollNumber >= 6 && _rollNumber <= 10) {
 return 46;
 } else if (_rollNumber >= 11 && _rollNumber <= 15) {
 return 47;
 } else if (_rollNumber >= 16 && _rollNumber <= 20) {
 return 48;
 } else if (_rollNumber >= 21 && _rollNumber <= 25) {
 return 49;
 }
 else if (_rollNumber >= 25 && _rollNumber <= 30) {
 return 50;
 }
 revert("Invalid roll number for classroom allocation.");
 }
function getAllocatedClassroom(uint256 _rollNumber) public view returns (uint256) {
 require(_rollNumber >= 1 && _rollNumber <= 30, "Invalid roll number. Must be between 1 and 30.");
 return studentinfo[_rollNumber-1].allocatedClassroom;
 }
}


-------------------------------------------------------------------------------------------------------

/* 6A : Write a Solidity Program to find whether a number is EVEN or ODD and another number is
PRIME or COMPOSITE and hence find the bitwise AND and bitwise OR of the result of the
product of the two numbers and if the result is EVEN then display a message,
"CONGRATULATION, YOU ARE SUCCESSFUL!!!"
*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract NumberOperations {
 uint256 and;
 uint256 or;
 uint256 num1;
 uint256 num2;
 function Input(uint256 number1,uint256 number2) public{
 num1=number1;
 num2=number2;
 and=num1&num2;
 or=num1|num2;
 }
 function evenODD() public view returns (string memory){
 if(num1%2==0){return "Number is even";}
 else{return "Number is odd";}
}
 function PrimeorNot() public view returns (string memory){

 if (num2 <= 1) {
 return "Neither prime nor composite";
 }
 for (uint256 i = 2; i <= num2/ 2; i++) {
 if (num2 % i == 0) {
 return "Composite number";
 }
 }
 return "Prime number";

 }
 function showResult() public view returns (string memory) {
 uint256 result;
 result= and*or;
 if(result%2==0){return "Congratulations you are successfull!";}
 else{return "Sorry, better luck next time :(";}
}
}


-------------------------------------------------------------------------------------------------------


/*6B: Write a solidity program to determine IF addition of two number is greater than any one of
the number then find the product of the lesser number and NOT of the greater Number ELSE
find the product of the greater number and NOT of lesser number.
*/

//SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.2 <0.9.0;
contract prac6b {

 function Check(int256 num1, int256 num2) public pure returns (int256 product){
 if ((num1 + num2) > num1 &&(num1 + num2) > num2) {

 if (num1 < num2) {
 product = num1 * ~num2;
 } else {
 product = num2 * ~num1;
 }
 return product;
 }
 }
}


-------------------------------------------------------------------------------------------------------


//7A Pure Function

//SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.2 <0.9.0;
contract Pure{
 function getResult(uint a, uint b) public pure returns(uint product, uint sum){
 product = a * b;
 sum = a + b;
 }
}

-------------------------------------------------------------------------------------------------------


//7B View Function

//SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.2 <0.9.0;
contract View{
 uint a;
 function input(uint num) public{
 a=num;
 }
 function getResult() public view returns(uint){
 return a+10;
 }
}


-------------------------------------------------------------------------------------------------------

//8A Withdrawal Pattern

//SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.2 <0.9.0;
contract WithdrawalPattern{
 address public richest;
 uint public mostSent;
mapping (address => uint) pendingWithdrawals;
 constructor() payable {
 richest = msg.sender;
 mostSent = msg.value;
 }
 function becomeRichest() public payable returns (bool) {
 if (msg.value > mostSent) {
 pendingWithdrawals[richest] += msg.value;
 richest = msg.sender;
 mostSent = msg.value;
 return true;
 } else {
 return false;
 } }
 function withdraw() public {
 address payable receiver = payable(msg.sender);
 uint amount = pendingWithdrawals[msg.sender];
 pendingWithdrawals[msg.sender] = 0;
 receiver.transfer(amount);
} }


-------------------------------------------------------------------------------------------------------

//8B Restricted Access

//SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.2 <0.9.0;
contract RestrictedAcess {
 uint public creationTime = block.timestamp;
 address payable owner = payable(msg.sender);
 modifier onlyBy(address _account) {
 require(
 msg.sender == _account,
 "Sender not authorized."
 );_; }
 function changeOwner(address _newOwner) public onlyBy(owner) {
 owner = payable(_newOwner);
 }
 modifier onlyAfter(uint _time) {
 require(
 block.timestamp >= _time,
 "Function called too early."
 );
 _;
 }
 function disown() public onlyBy(owner) onlyAfter(creationTime + 6 weeks) {
 delete owner;
 }
 modifier costs(uint _amount) {
 require(
 msg.value >= _amount,
 "Not enough Ether provided."
 );
 _;
 if (msg.value > _amount){
 owner.transfer(msg.value - _amount);
 }
 }
 function forceOwnerChange(address _newOwner) public payable costs(200 ether) {
 owner = payable(_newOwner);
 if (owner.balance & 0 == 1) return;
 }
}


-------------------------------------------------------------------------------------------------------

//9A Multilevel Inheritance

//SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.2 <0.9.0;
contract A {
 function getAValue() external pure returns(string memory){
 return "contract A is called";
 }
}
contract B is A {
 function getBValue() external pure returns(string memory){
 return "contract B is called";
 }
}
contract C is B {
 function getCValue() external pure returns(string memory){
 return "contract C is called";
 }
}
contract caller {
 C contractC = new C();
 function testInheritance() public view returns (string memory, string memory, string memory) {
 return (contractC.getAValue(), contractC.getBValue(), contractC.getCValue());
 }
}


-------------------------------------------------------------------------------------------------------


// 9B Hierarchical Inheritance

//SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.2 <0.9.0;
contract A {
 function getAValue() external pure returns(string memory){
 return "contract A is called";
 }
} contract B is A {

} contract C is A {

}
contract caller {
 B contractB = new B();
 C contractC = new C();

 function testInheritance() public view returns (string memory, string memory) {
 return (contractB.getAValue(), contractC.getAValue());
 }
}


-------------------------------------------------------------------------------------------------------


//9C
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.2 <0.9.0;
contract C{
uint private data;
uint public info;
constructor() {
info = 10;
}
function increment(uint a) private pure returns(uint) { return a+1; }
function updateData(uint a) public { data = a;}
function getData() public view returns(uint) {return data;}
function compute(uint a, uint b) internal pure returns(uint) {return
a+b;}
}
contract E is C{
uint private result;
C private c;
constructor() {
c = new C();
}
function getComputedResult() public {result = compute(3, 5);}
function getResult() public view returns(uint) {return result;}
function getDatafromC() public view returns(uint) {return c.info();}
}


-------------------------------------------------------------------------------------------------------

